/**
 * HotReloadManager.js
 * 
 * Sistema de hot reload para o Zap Bot sem perder conex√£o WhatsApp
 * Permite atualiza√ß√µes de c√≥digo em tempo real durante testes de massa
 */

const fs = require('fs').promises;
const path = require('path');
const chokidar = require('chokidar');

class HotReloadManager {
    constructor(options = {}) {
        this.watchPaths = options.watchPaths || ['./'];
        this.excludePaths = options.excludePaths || [
            'node_modules/**',
            'session/**',
            'whatsapp_data/**',
            '.git/**',
            'logs/**',
            '*.log'
        ];
        this.debounceDelay = options.debounceDelay || 2000; // 2 segundos
        this.isReloading = false;
        this.reloadTimer = null;
        this.moduleCache = new Map();
        this.watchers = [];
        this.reloadCallbacks = new Map();
        this.isEnabled = process.env.NODE_ENV !== 'production';
        
        console.log(`üî• HotReloadManager ${this.isEnabled ? 'ATIVADO' : 'DESATIVADO'}`);
    }

    /**
     * Inicia o sistema de hot reload
     */
    async start() {
        if (!this.isEnabled) {
            console.log('‚ö†Ô∏è Hot reload desabilitado em produ√ß√£o');
            return;
        }

        try {
            console.log('üî• Iniciando sistema de hot reload...');
            
            // Configurar watchers para diferentes tipos de arquivo
            await this.setupFileWatchers();
            
            // Cachear m√≥dulos importantes
            await this.cacheImportantModules();
            
            console.log('‚úÖ Hot reload ativo! Monitorando mudan√ßas...');
            
        } catch (error) {
            console.error('‚ùå Erro ao iniciar hot reload:', error);
        }
    }

    /**
     * Configura watchers para diferentes tipos de arquivo
     */
    async setupFileWatchers() {
        // Watcher principal para arquivos .js
        const jsWatcher = chokidar.watch('*.js', {
            ignored: this.excludePaths,
            persistent: true,
            ignoreInitial: true
        });

        jsWatcher.on('change', (filePath) => {
            this.scheduleReload('javascript', filePath);
        });

        // Watcher para arquivos de configura√ß√£o
        const configWatcher = chokidar.watch(['package.json', '.env*'], {
            persistent: true,
            ignoreInitial: true
        });

        configWatcher.on('change', (filePath) => {
            this.scheduleReload('config', filePath);
        });

        // Watcher para novos m√≥dulos
        const moduleWatcher = chokidar.watch(['./modules/**/*.js', './services/**/*.js'], {
            persistent: true,
            ignoreInitial: true
        });

        moduleWatcher.on('add', (filePath) => {
            this.scheduleReload('new_module', filePath);
        });

        moduleWatcher.on('change', (filePath) => {
            this.scheduleReload('module', filePath);
        });

        this.watchers.push(jsWatcher, configWatcher, moduleWatcher);
    }

    /**
     * Agenda um reload com debounce
     */
    scheduleReload(type, filePath) {
        if (this.isReloading) {
            return;
        }

        console.log(`üìù Mudan√ßa detectada: ${type} - ${filePath}`);

        // Cancelar timer anterior
        if (this.reloadTimer) {
            clearTimeout(this.reloadTimer);
        }

        // Agendar novo reload
        this.reloadTimer = setTimeout(async () => {
            await this.performHotReload(type, filePath);
        }, this.debounceDelay);
    }

    /**
     * Executa o hot reload baseado no tipo de mudan√ßa
     */
    async performHotReload(type, filePath) {
        if (this.isReloading) {
            return;
        }

        try {
            this.isReloading = true;
            console.log(`üî• Iniciando hot reload: ${type} - ${filePath}`);

            switch (type) {
                case 'javascript':
                    await this.reloadJavaScriptModule(filePath);
                    break;
                    
                case 'config':
                    await this.reloadConfiguration(filePath);
                    break;
                    
                case 'module':
                case 'new_module':
                    await this.reloadModule(filePath);
                    break;
                    
                default:
                    console.log(`‚ö†Ô∏è Tipo de reload n√£o suportado: ${type}`);
            }

            console.log(`‚úÖ Hot reload conclu√≠do: ${filePath}`);

        } catch (error) {
            console.error(`‚ùå Erro durante hot reload de ${filePath}:`, error);
        } finally {
            this.isReloading = false;
        }
    }

    /**
     * Recarrega um m√≥dulo JavaScript
     */
    async reloadJavaScriptModule(filePath) {
        try {
            const fullPath = path.resolve(filePath);
            
            // Limpar cache do m√≥dulo
            if (require.cache[fullPath]) {
                delete require.cache[fullPath];
                console.log(`üóëÔ∏è Cache limpo: ${filePath}`);
            }

            // Se for um m√≥dulo que conhecemos, tentar recarregar
            if (this.moduleCache.has(filePath)) {
                const moduleInfo = this.moduleCache.get(filePath);
                
                try {
                    const newModule = require(fullPath);
                    this.moduleCache.set(filePath, { 
                        module: newModule, 
                        lastReload: Date.now() 
                    });
                    
                    // Executar callbacks de reload se existirem
                    if (this.reloadCallbacks.has(filePath)) {
                        const callback = this.reloadCallbacks.get(filePath);
                        await callback(newModule, moduleInfo.module);
                    }
                    
                    console.log(`üîÑ M√≥dulo recarregado: ${filePath}`);
                    
                } catch (error) {
                    console.error(`‚ùå Erro ao recarregar m√≥dulo ${filePath}:`, error);
                }
            }

        } catch (error) {
            console.error(`‚ùå Erro durante reload de JavaScript: ${error}`);
        }
    }

    /**
     * Recarrega configura√ß√£o
     */
    async reloadConfiguration(filePath) {
        try {
            if (filePath.includes('package.json')) {
                console.log('üì¶ package.json alterado - recarregamento autom√°tico n√£o suportado');
                console.log('üí° Considere reiniciar o processo para mudan√ßas em depend√™ncias');
            }
            
            if (filePath.includes('.env')) {
                console.log('üîß Arquivo .env alterado - recarregando vari√°veis...');
                
                // Recarregar vari√°veis de ambiente
                require('dotenv').config({ override: true });
                
                console.log('‚úÖ Vari√°veis de ambiente recarregadas');
            }

        } catch (error) {
            console.error(`‚ùå Erro ao recarregar configura√ß√£o: ${error}`);
        }
    }

    /**
     * Recarrega um m√≥dulo espec√≠fico
     */
    async reloadModule(filePath) {
        try {
            // Implementa√ß√£o espec√≠fica para m√≥dulos customizados
            await this.reloadJavaScriptModule(filePath);
            
        } catch (error) {
            console.error(`‚ùå Erro ao recarregar m√≥dulo: ${error}`);
        }
    }

    /**
     * Cacheia m√≥dulos importantes para reload
     */
    async cacheImportantModules() {
        const importantModules = [
            './WhatsAppDataExtractor.js',
            './emoji-resilience-processor.js'
        ];

        for (const modulePath of importantModules) {
            try {
                const fullPath = path.resolve(modulePath);
                
                if (await this.fileExists(fullPath)) {
                    const module = require(fullPath);
                    this.moduleCache.set(modulePath, { 
                        module, 
                        lastReload: Date.now() 
                    });
                    console.log(`üìã M√≥dulo cacheado: ${modulePath}`);
                }
                
            } catch (error) {
                console.log(`‚ö†Ô∏è N√£o foi poss√≠vel cachear ${modulePath}:`, error.message);
            }
        }
    }

    /**
     * Registra callback para reload de m√≥dulo espec√≠fico
     */
    onModuleReload(modulePath, callback) {
        this.reloadCallbacks.set(modulePath, callback);
        console.log(`üîó Callback registrado para: ${modulePath}`);
    }

    /**
     * Remove callback de reload
     */
    removeModuleReload(modulePath) {
        this.reloadCallbacks.delete(modulePath);
        console.log(`üóëÔ∏è Callback removido para: ${modulePath}`);
    }

    /**
     * For√ßa reload de um m√≥dulo espec√≠fico
     */
    async forceReload(modulePath) {
        console.log(`üî® For√ßando reload: ${modulePath}`);
        await this.performHotReload('javascript', modulePath);
    }

    /**
     * Obt√©m estat√≠sticas do hot reload
     */
    getStats() {
        return {
            isEnabled: this.isEnabled,
            isReloading: this.isReloading,
            cachedModules: this.moduleCache.size,
            activeWatchers: this.watchers.length,
            registeredCallbacks: this.reloadCallbacks.size,
            lastReload: this.lastReloadTime
        };
    }

    /**
     * Para o sistema de hot reload
     */
    async stop() {
        try {
            console.log('üõë Parando hot reload...');
            
            // Parar todos os watchers
            for (const watcher of this.watchers) {
                await watcher.close();
            }
            
            // Limpar timers
            if (this.reloadTimer) {
                clearTimeout(this.reloadTimer);
            }
            
            // Limpar caches
            this.moduleCache.clear();
            this.reloadCallbacks.clear();
            
            console.log('‚úÖ Hot reload parado');
            
        } catch (error) {
            console.error('‚ùå Erro ao parar hot reload:', error);
        }
    }

    // ==================== M√âTODOS AUXILIARES ====================

    async fileExists(filePath) {
        try {
            await fs.access(filePath);
            return true;
        } catch {
            return false;
        }
    }

    /**
     * Cria interface de comando para hot reload
     */
    createCommandInterface() {
        return {
            // Comando para for√ßar reload
            reload: async (modulePath) => {
                if (modulePath) {
                    await this.forceReload(modulePath);
                } else {
                    console.log('üìã M√≥dulos dispon√≠veis para reload:');
                    for (const [path, info] of this.moduleCache.entries()) {
                        const lastReload = new Date(info.lastReload).toLocaleString('pt-BR');
                        console.log(`  ‚Ä¢ ${path} (√∫ltimo reload: ${lastReload})`);
                    }
                }
            },
            
            // Comando para ver estat√≠sticas
            stats: () => {
                const stats = this.getStats();
                console.log('üìä Estat√≠sticas do Hot Reload:');
                console.log(`  ‚Ä¢ Status: ${stats.isEnabled ? '‚úÖ Ativo' : '‚ùå Inativo'}`);
                console.log(`  ‚Ä¢ Reloading: ${stats.isReloading ? 'Sim' : 'N√£o'}`);
                console.log(`  ‚Ä¢ M√≥dulos cacheados: ${stats.cachedModules}`);
                console.log(`  ‚Ä¢ Watchers ativos: ${stats.activeWatchers}`);
                console.log(`  ‚Ä¢ Callbacks registrados: ${stats.registeredCallbacks}`);
            },
            
            // Comando para parar hot reload
            stop: async () => {
                await this.stop();
            }
        };
    }
}

module.exports = HotReloadManager;
