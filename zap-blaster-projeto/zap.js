// zap.js - Vers√£o final usando whatsapp-web.js
const { Client, LocalAuth } = require('whatsapp-web.js');
const amqp = require('amqplib');
const express = require('express');
const cors = require('cors');
const http = require('http');
const { Server } = require('socket.io');
const qrcode = require('qrcode-terminal');
const path = require('path');
const fs = require('fs');
require('dotenv').config();

// Configura√ß√µes de rede para simular IP do celular
const CELLULAR_IP = '179.68.104.112';
const CELLULAR_PORT = '8080';

// Configurar timezone e localiza√ß√£o para Brasil
process.env.TZ = 'America/Sao_Paulo';
process.env.LANG = 'pt_BR.UTF-8';
process.env.LC_ALL = 'pt_BR.UTF-8';

console.log(`üåç Configurando timezone: America/Sao_Paulo`);
console.log(`üáßüá∑ Configurando localiza√ß√£o: pt_BR.UTF-8`);

const instanceId = process.env.INSTANCE_ID || 'zap-prod';

// Caminho da sess√£o que funciona tanto localmente quanto no Docker
const isDocker = process.env.NODE_ENV === 'production' || fs.existsSync('/.dockerenv');
const sessionPath = isDocker 
  ? `/app/session/${instanceId}`
  : path.join(process.cwd(), 'session', instanceId);

// Criar diret√≥rio de sess√£o se n√£o existir
const sessionDir = path.dirname(sessionPath);
if (!fs.existsSync(sessionDir)) {
  try {
    fs.mkdirSync(sessionDir, { recursive: true });
    console.log(`üìÅ Diret√≥rio de sess√£o criado: ${sessionDir}`);
  } catch (error) {
    console.error(`‚ùå Erro ao criar diret√≥rio de sess√£o: ${error.message}`);
    // Fallback para diret√≥rio local
    const localSessionDir = path.join(process.cwd(), 'session', instanceId);
    fs.mkdirSync(path.dirname(localSessionDir), { recursive: true });
    console.log(`üìÅ Usando diret√≥rio local: ${localSessionDir}`);
  }
}

const rabbitConfig = {
  protocol: 'amqps',
  hostname: process.env.RABBITMQ_HOST || 'mouse.rmq5.cloudamqp.com',
  port: parseInt(process.env.RABBITMQ_PORT || '5671', 10),
  username: process.env.RABBITMQ_USER || 'ewxcrhtv',
  password: process.env.RABBITMQ_PASS || 'DNcdH0NEeP4Fsgo2_w-vd47CqjelFk_S',
  vhost: process.env.RABBITMQ_VHOST || 'ewxcrhtv'
};

const RABBITMQ_URL =
  process.env.RABBITMQ_URL ||
  `amqps://${encodeURIComponent(rabbitConfig.username)}:${encodeURIComponent(rabbitConfig.password)}@${rabbitConfig.hostname}:${rabbitConfig.port}/${encodeURIComponent(rabbitConfig.vhost)}`;

// Vari√°veis de controle de estado
let isConnected = false;
let isFullyValidated = false;
let connectedNumber = null;
let isSenderAllowed = true;
let qrCodeTimer = null;
let qrCodeStartTime = null;
let validationTimer = null;
let messageQueue = [];
const QR_CODE_DURATION = 3 * 60 * 1000; // 3 minutos em millisegundos
const VALIDATION_DELAY = 10000; // 10 segundos para valida√ß√£o completa

// Vari√°veis globais de conex√£o
let rabbitConnection = null;
let rabbitChannel = null;

// Loopback DEV
const DEV_LOOPBACK = (process.env.DEV_LOOPBACK_INBOUND === 'true') || (process.env.NODE_ENV !== 'production');

// Fun√ß√£o para limpar timer do QR Code
function clearQRCodeTimer() {
  if (qrCodeTimer) {
    clearTimeout(qrCodeTimer);
    qrCodeTimer = null;
  }
}

// Fun√ß√£o para limpar timer de valida√ß√£o
function clearValidationTimer() {
  if (validationTimer) {
    clearTimeout(validationTimer);
    validationTimer = null;
  }
}

// Pol√≠ticas de sess√£o: Manter sess√£o existente se v√°lida
function clearAllSessions() {
  try {
    if (fs.existsSync(sessionPath)) {
      console.log('üìÅ Sess√£o existente encontrada:', sessionPath);
      // N√£o remover automaticamente - deixar o usu√°rio decidir
    }
  } catch (err) {
    console.error('‚ö†Ô∏è Erro ao verificar sess√£o:', err?.message || err);
  }
}

// Fun√ß√£o para validar conex√£o completamente
async function validateConnection() {
  try {
    console.log('üîç Validando conex√£o...');
    
    // Verificar se o cliente est√° realmente conectado
    if (!client.info || !client.info.wid) {
      console.log('‚ùå Cliente n√£o tem informa√ß√µes v√°lidas');
      return false;
    }

    // Verificar se o n√∫mero est√° dispon√≠vel
    const number = client.info.wid.user;
    if (!number) {
      console.log('‚ùå N√∫mero n√£o dispon√≠vel');
      return false;
    }

    // Testar uma opera√ß√£o simples para verificar se est√° funcionando
    try {
      // Testar obten√ß√£o de chats
      const chats = await client.getChats();
      if (!chats || chats.length === 0) {
        console.log('‚ö†Ô∏è Nenhum chat encontrado - pode indicar problema de conex√£o');
      }
      
      // Testar uma opera√ß√£o de envio simples (sem enviar)
      try {
        const testChat = chats && chats.length > 0 ? chats[0] : null;
        if (testChat) {
          // Verificar se conseguimos acessar propriedades do chat
          const chatId = testChat.id;
          if (!chatId) {
            console.log('‚ö†Ô∏è Chat sem ID v√°lido');
          }
        }
      } catch (testError) {
        console.log('‚ö†Ô∏è Erro ao testar opera√ß√µes de chat:', testError.message);
      }
      
      console.log('‚úÖ Conex√£o validada com sucesso!');
      return true;
    } catch (error) {
      console.log('‚ùå Erro ao validar conex√£o:', error.message);
      return false;
    }
  } catch (error) {
    console.log('‚ùå Erro durante valida√ß√£o:', error.message);
    return false;
  }
}

// Fun√ß√£o para processar fila de mensagens pendentes
async function processMessageQueue() {
  if (messageQueue.length === 0) return;
  
  console.log(`üì¶ Processando ${messageQueue.length} mensagens pendentes...`);
  
  for (const queuedMessage of messageQueue) {
    try {
      const result = await sendOne(client, queuedMessage.phone, queuedMessage.messageData);
      
      if (result.success) {
        console.log(`‚úÖ Mensagem pendente enviada para ${queuedMessage.phone}`);
      } else {
        console.log(`‚ùå Falha ao enviar mensagem pendente para ${queuedMessage.phone}: ${result.reason}`);
      }
    } catch (error) {
      console.error(`‚ùå Erro ao processar mensagem pendente: ${error.message}`);
    }
  }
  
  messageQueue = [];
  console.log('üì¶ Fila de mensagens processada');
}

// Fun√ß√£o para mostrar status da conex√£o
function showConnectionStatus() {
  if (isConnected && isFullyValidated && connectedNumber) {
    console.log(`\nüì± STATUS: CONECTADO E VALIDADO`);
    console.log(`üìû N√∫mero conectado: ${connectedNumber}`);
    console.log(`üÜî Inst√¢ncia: ${instanceId}`);
    console.log(`‚è∞ Conectado desde: ${new Date().toLocaleString('pt-BR')}`);
    console.log(`‚úÖ Pronto para receber mensagens da fila`);
    console.log(`üîí GARANTIA: Todas as mensagens ser√£o enviadas APENAS atrav√©s do n√∫mero ${connectedNumber}\n`);
  } else if (isConnected && !isFullyValidated) {
    console.log(`\nüì± STATUS: CONECTADO - VALIDANDO`);
    console.log(`üìû N√∫mero conectado: ${connectedNumber || 'N/A'}`);
    console.log(`‚è≥ Aguardando valida√ß√£o completa...\n`);
  } else {
    console.log(`\nüì± STATUS: DESCONECTADO`);
    console.log(`‚ùå Aguardando conex√£o do WhatsApp\n`);
  }
}

// Fun√ß√£o de valida√ß√£o de seguran√ßa peri√≥dica
function validateSecurityIntegrity() {
  if (isConnected && isFullyValidated && connectedNumber) {
    const ownNumber = client.info?.wid?.user;
    const normalizedOwn = normalizeNumber(ownNumber);
    const normalizedConnected = normalizeNumber(connectedNumber);
    
    if (normalizedOwn !== normalizedConnected) {
      console.log('üö® ALERTA DE SEGURAN√áA: Inconsist√™ncia detectada no n√∫mero conectado!');
      console.log(`üìû N√∫mero conectado: ${connectedNumber}`);
      console.log(`üÜî N√∫mero do cliente: ${ownNumber}`);
      console.log('üõë Encerrando bot por seguran√ßa...');
      process.exit(1);
    } else {
      console.log('‚úÖ Valida√ß√£o de seguran√ßa: N√∫mero conectado consistente');
    }
  }
}

function normalizeNumber(num) {
  if (!num) return null;
  
  // Remover todos os caracteres n√£o num√©ricos
  let cleanNumber = String(num).replace(/\D/g, '');
  
  // Se o n√∫mero j√° tem c√≥digo do pa√≠s (come√ßa com 55 para Brasil), retornar como est√°
  if (cleanNumber.startsWith('55') && cleanNumber.length >= 12) {
    return cleanNumber;
  }
  
  // Se o n√∫mero tem 11 d√≠gitos (formato brasileiro sem c√≥digo do pa√≠s), adicionar 55
  if (cleanNumber.length === 11) {
    return '55' + cleanNumber;
  }
  
  // Se o n√∫mero tem 10 d√≠gitos (formato brasileiro sem c√≥digo do pa√≠s e sem DDD), adicionar 55
  if (cleanNumber.length === 10) {
    return '55' + cleanNumber;
  }
  
  // Se o n√∫mero tem 9 d√≠gitos (celular brasileiro sem c√≥digo do pa√≠s), adicionar 5511
  if (cleanNumber.length === 9) {
    return '5511' + cleanNumber;
  }
  
  // Se o n√∫mero tem 8 d√≠gitos (telefone fixo brasileiro sem c√≥digo do pa√≠s), adicionar 5511
  if (cleanNumber.length === 8) {
    return '5511' + cleanNumber;
  }
  
  // Para outros casos, assumir que √© brasileiro e adicionar 55
  if (cleanNumber.length > 0) {
    return '55' + cleanNumber;
  }
  
  return cleanNumber;
}

// Configura√ß√£o melhorada do cliente WhatsApp
const client = new Client({
  authStrategy: new LocalAuth({ 
    dataPath: sessionPath,
    clientId: instanceId
  }),
  restartOnAuthFail: true,
  authTimeoutMs: 60000, // Reduzir timeout para 60s
  puppeteer: {
    headless: true,
    args: [
      '--no-sandbox',
      '--disable-setuid-sandbox',
      '--disable-dev-shm-usage',
      '--disable-gpu',
      '--no-first-run',
      '--disable-extensions',
      '--disable-plugins',
      '--disable-default-apps',
      '--disable-sync',
      '--disable-translate',
      '--hide-scrollbars',
      '--mute-audio',
      '--no-default-browser-check',
      '--disable-background-timer-throttling',
      '--disable-backgrounding-occluded-windows',
      '--disable-renderer-backgrounding',
      '--disable-features=TranslateUI',
      '--disable-ipc-flooding-protection',
      '--disable-web-security',
      '--disable-features=VizDisplayCompositor',
      '--disable-component-extensions-with-background-pages',
      '--disable-background-networking',
      '--disable-client-side-phishing-detection',
      '--disable-domain-reliability',
      '--disable-features=AudioServiceOutOfProcess',
      '--disable-hang-monitor',
      '--disable-prompt-on-repost',
      '--force-color-profile=srgb',
      '--metrics-recording-only',
      '--safebrowsing-disable-auto-update',
      '--password-store=basic',
      '--use-mock-keychain',
      '--ignore-certificate-errors',
      '--ignore-ssl-errors',
      '--ignore-certificate-errors-spki-list',
      '--user-agent=Mozilla/5.0 (Linux; Android 10; SM-A505FN) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36'
    ]
  },
  // Configura√ß√£o mais limpa para evitar detec√ß√£o
  webVersionCache: { type: 'local' },
  // Configura√ß√µes de rede para simular IP do celular
  userAgent: 'Mozilla/5.0 (Linux; Android 10; SM-A505FN) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36',
  // Configura√ß√µes de localiza√ß√£o
  locale: 'pt-BR',
  timezone: 'America/Sao_Paulo'
});

const QRCode = require('qrcode');
const axios = require('axios');

// Fun√ß√£o para processar templates de mensagem
function processMessageTemplate(template, data) {
  if (typeof template !== 'string') {
    return JSON.stringify(template);
  }

  let processedMessage = template;

  // Substituir vari√°veis do template
  if (data) {
    // Substituir vari√°veis b√°sicas
    Object.keys(data).forEach(key => {
      const regex = new RegExp(`{{${key}}}`, 'gi');
      processedMessage = processedMessage.replace(regex, data[key] || '');
    });

    // Substituir vari√°veis especiais
    processedMessage = processedMessage
      .replace(/{{currentDate}}/gi, new Date().toLocaleDateString('pt-BR'))
      .replace(/{{currentTime}}/gi, new Date().toLocaleTimeString('pt-BR'))
      .replace(/{{timestamp}}/gi, new Date().toISOString())
      .replace(/{{instanceId}}/gi, instanceId)
      .replace(/{{senderNumber}}/gi, connectedNumber || 'N/A');
  }

  return processedMessage;
}

// Melhor tratamento de eventos com bypass da Meta
client.on('qr', async (qr) => {
  clearQRCodeTimer();
  
  console.log('üì± ESCANEIE O QR CODE NO TERMINAL:');
  console.log('‚è∞ QR Code v√°lido por 3 minutos\n');
  
  // Gerar QR code com estilo da Meta (logo do WhatsApp)
  qrcode.generate(qr, { small: true });

  try {
    // Gerar QR code com logo do WhatsApp (estilo Meta)
    const qrWithLogo = await QRCode.toDataURL(qr, {
      errorCorrectionLevel: 'H',
      type: 'image/png',
      quality: 0.92,
      margin: 1,
      color: {
        dark: '#000000',
        light: '#FFFFFF'
      },
      width: 300
    });

    console.log('\nüîó QR Code com logo WhatsApp (estilo Meta):\n');
    console.log(qrWithLogo);
    console.log('\nüëâ Acesse https://goqr.me e cole o conte√∫do acima para escanear.');
    
    // Enviar QR para RabbitMQ
    if (rabbitChannel) {
      const qrCodeQueue = 'out.qrcode';
      const qrCodeMessage = { qrCode: qrWithLogo, instanceId: instanceId, type: 'qr_code' };
      const messageBuffer = Buffer.from(JSON.stringify(qrCodeMessage));
      await rabbitChannel.sendToQueue(qrCodeQueue, messageBuffer, { persistent: true });
      console.log('üì® QR enviado para fila RabbitMQ:', qrCodeQueue);
    }
    
    // Enviar QR para API para o front consumir
    const apiBaseUrl = process.env.API_URL || 'http://localhost:5656';
    try {
      await axios.post(`${apiBaseUrl}/api/whatsapp/webhook/qr-code`, { 
        qrCode: qrWithLogo,
        timestamp: new Date().toISOString(),
        instanceId: instanceId
      });
      console.log('üì® QR enviado para API');
    } catch (postErr) {
      console.error('‚ö†Ô∏è Falha ao postar QR na API:', postErr?.message || postErr);
    }
    
    // Timer para expirar o QR Code
    qrCodeStartTime = Date.now();
    qrCodeTimer = setTimeout(() => {
      if (!isConnected) {
        console.log('\n‚è∞ QR Code expirado! Reinicie o bot para gerar um novo.');
      }
    }, QR_CODE_DURATION);
    
  } catch (error) {
    console.error('‚ùå Erro ao gerar QR code:', error.message);
  }
});

client.on('ready', async () => {
  clearQRCodeTimer();
  
  console.log('üîê QR Code escaneado! Implementando bypass da Meta...');
  console.log('‚è≥ Aguardando delay de seguran√ßa (5 segundos)...');
  
  // DELAY DE SEGURAN√áA: Aguardar 5 segundos para evitar detec√ß√£o da Meta
  await new Promise(resolve => setTimeout(resolve, 5000));
  
  console.log('‚úÖ Delay conclu√≠do. Iniciando conex√£o...');
  
  isConnected = true;
  connectedNumber = client.info?.wid?.user || 'N/A';
  isFullyValidated = false;
  
  // VALIDA√á√ÉO CR√çTICA: Garantir que o n√∫mero conectado √© v√°lido
  if (!connectedNumber || connectedNumber === 'N/A') {
    console.log('‚ùå N√∫mero conectado inv√°lido ou n√£o dispon√≠vel');
    isConnected = false;
    connectedNumber = null;
    showConnectionStatus();
    emitStatus();
    await sendSessionStatusToAPI();
    return;
  }
  
  console.log('‚úÖ Cliente WhatsApp conectado com sucesso!');
  console.log(`üîí GARANTIA: Bot conectado com n√∫mero ${connectedNumber}`);
  console.log(`üõ°Ô∏è Todas as mensagens ser√£o enviadas APENAS atrav√©s deste n√∫mero`);
  console.log('üöÄ Bypass da Meta implementado com sucesso!');
  
  showConnectionStatus();
  emitStatus();
  await sendSessionStatusToAPI();
  
  // Aguardar um tempo antes de validar para evitar problemas de sincroniza√ß√£o
  console.log('‚è≥ Aguardando estabiliza√ß√£o da conex√£o...');
  
  validationTimer = setTimeout(async () => {
    const isValid = await validateConnection();
    
    if (isValid) {
      isFullyValidated = true;
      showConnectionStatus();
      emitStatus();
      await sendSessionStatusToAPI();
      
      // Processar mensagens pendentes
      await processMessageQueue();
      
      // Iniciar consumidor da fila
      await startQueueConsumer(client);
    } else {
      console.log('‚ùå Falha na valida√ß√£o. Gere um novo QR para conectar.');
      isConnected = false;
      connectedNumber = null;
      showConnectionStatus();
      emitStatus();
      await sendSessionStatusToAPI();
    }
  }, VALIDATION_DELAY);
});

client.on('auth_failure', (msg) => {
  clearQRCodeTimer();
  clearValidationTimer();
  isConnected = false;
  isFullyValidated = false;
  connectedNumber = null;
  console.error('‚ùå Falha de autentica√ß√£o:', msg);
  console.log('üîÑ Tente escanear o QR code novamente.');
  showConnectionStatus();
  emitStatus();
  sendSessionStatusToAPI();
});

client.on('disconnected', (reason) => {
  clearQRCodeTimer();
  clearValidationTimer();
  isConnected = false;
  isFullyValidated = false;
  connectedNumber = null;
  console.log('üîå Cliente desconectado:', reason);
  console.log('üîÑ Tentando reconectar...');
  showConnectionStatus();
  emitStatus();
  sendSessionStatusToAPI();
});

client.on('loading_screen', (percent, message) => {
  console.log(`‚è≥ Carregando: ${percent}% - ${message}`);
});

// Evento para mensagens recebidas
client.on('message', async (message) => {
  try {
    // Ignorar mensagens enviadas pelo pr√≥prio bot
    if (message.fromMe) {
      console.log(`ü§ñ Ignorando mensagem enviada pelo pr√≥prio bot: ${message.body}`);
      return;
    }

    // Normalizar o n√∫mero do remetente
    const senderNumber = message.from.split('@')[0];
    const normalizedSenderNumber = normalizeNumber(senderNumber);

    // Log detalhado da mensagem recebida
    console.log(`üì® NOVA MENSAGEM RECEBIDA:`);
    console.log(`   üì± De (original): ${message.from}`);
    console.log(`   üì± De (normalizado): ${normalizedSenderNumber}`);
    console.log(`   üí¨ Conte√∫do: ${message.body}`);
    console.log(`   üìÖ Timestamp: ${new Date().toISOString()}`);
    console.log(`   üÜî Message ID: ${message.id._serialized}`);
    console.log(`   üìã Tipo: ${message.type}`);
    console.log(`   üìç Chat: ${senderNumber}`);

    // Verificar se √© mensagem de texto (por enquanto s√≥ trabalhamos com texto)
    if (message.type !== 'chat' && message.type !== 'text') {
      console.log(`‚ö†Ô∏è Mensagem n√£o √© de texto (tipo: ${message.type}), ignorando por enquanto`);
      return;
    }

    // Verificar se o n√∫mero est√° no formato correto
    if (!normalizedSenderNumber || normalizedSenderNumber.length < 10) {
      console.log(`‚ö†Ô∏è N√∫mero do remetente inv√°lido: ${senderNumber} -> ${normalizedSenderNumber}`);
      return;
    }

    // Enviar mensagem para a API via RabbitMQ
    console.log(`üì§ Enviando mensagem para API via RabbitMQ...`);
    await sendMessageToAPI(message);
    console.log(`‚úÖ Mensagem processada com sucesso!`);
  } catch (error) {
    console.error('‚ùå Erro ao processar mensagem recebida:', error.message);
    console.error('Stack trace:', error.stack);
  }
});

// Fun√ß√£o para enviar mensagens recebidas para a API via RabbitMQ
async function sendMessageToAPI(message) {
  try {
    console.log(`üîå Verificando conex√£o RabbitMQ...`);
    
    // Verificar se h√° conex√£o RabbitMQ
    if (!rabbitConnection || !rabbitChannel) {
      console.log('‚ö†Ô∏è RabbitMQ n√£o conectado, tentando conectar...');
      await startQueueConsumer(client);
      
      // Aguardar um pouco para a conex√£o ser estabelecida
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      if (!rabbitConnection || !rabbitChannel) {
        console.error('‚ùå Falha ao conectar com RabbitMQ');
        return;
      }
    }

    // Normalizar o n√∫mero do remetente
    const senderNumber = message.from.split('@')[0];
    const normalizedSenderNumber = normalizeNumber(senderNumber);

    // Preparar dados da mensagem no formato esperado pela API
    const messageData = {
      externalMessageId: message.id._serialized,
      from: normalizedSenderNumber,
      fromNormalized: normalizedSenderNumber,
      to: connectedNumber,
      body: message.body,
      type: message.type,
      timestamp: new Date().toISOString(),
      instanceId: instanceId,
      fromMe: false,
      isGroup: false,
      chatId: `chat_${normalizedSenderNumber}`
    };

    console.log(`üìã Dados da mensagem preparados:`, JSON.stringify(messageData, null, 2));

    // Enviar para fila RabbitMQ correta
    const queueName = 'whatsapp.incoming';
    const messageBuffer = Buffer.from(JSON.stringify(messageData));
    
    console.log(`üì§ Enviando para fila RabbitMQ: ${queueName}`);
    await rabbitChannel.assertQueue(queueName, { durable: true });
    await rabbitChannel.sendToQueue(queueName, messageBuffer, {
      persistent: true,
      headers: {
        'content-type': 'application/json',
        'timestamp': new Date().toISOString()
      }
    });

    console.log(`‚úÖ Mensagem enviada para RabbitMQ com sucesso: ${message.from}`);
    console.log(`üìä Fila: ${queueName}`);
    console.log(`üÜî Message ID: ${message.id._serialized}`);
  } catch (error) {
    console.error('‚ùå Erro ao enviar mensagem para API:', error.message);
    console.error('Stack trace:', error.stack);
  }
}

// Fun√ß√£o para enviar confirma√ß√£o de envio de mensagem para a API
async function sendMessageConfirmationToAPI(phone, messageId, status) {
  try {
    // Verificar se h√° conex√£o RabbitMQ
    if (!rabbitConnection || !rabbitChannel) {
      console.log('‚ö†Ô∏è RabbitMQ n√£o conectado, tentando conectar...');
      await startQueueConsumer(client);
      return;
    }

    // Preparar dados da confirma√ß√£o
    const confirmationData = {
      phone: phone,
      messageId: messageId,
      status: status,
      timestamp: new Date().toISOString(),
      instanceId: instanceId
    };

    // Enviar para fila RabbitMQ correta
    const queueName = 'whatsapp.message-status';
    const messageBuffer = Buffer.from(JSON.stringify(confirmationData));
    
    await rabbitChannel.assertQueue(queueName, { durable: true });
    await rabbitChannel.sendToQueue(queueName, messageBuffer, {
      persistent: true,
      headers: {
        'content-type': 'application/json',
        'timestamp': new Date().toISOString()
      }
    });

    console.log(`üì§ Confirma√ß√£o de status enviada para RabbitMQ: ${messageId} - ${status}`);
  } catch (error) {
    console.error('‚ùå Erro ao enviar confirma√ß√£o de status:', error.message);
  }
}

// Fun√ß√£o melhorada para envio de mensagens com templates
async function sendOne(client, number, messageData) {
  // VALIDA√á√ÉO CR√çTICA: Garantir que o bot est√° conectado e autenticado
  if (!client || !client.info || !client.info.wid) {
    console.log('‚ùå Cliente WhatsApp n√£o est√° inicializado ou autenticado');
    return { success: false, reason: 'client_not_authenticated' };
  }

  // Verificar se est√° completamente validado
  if (!isFullyValidated) {
    console.log(`‚è≥ Mensagem para ${number} adicionada √† fila - aguardando valida√ß√£o`);
    messageQueue.push({ phone: number, messageData });
    return { success: false, reason: 'waiting_validation' };
  }

  const ownNumber = client.info?.wid?.user;

  // Somente enviar/receber com o n√∫mero atualmente conectado no bot
  const normalizedOwn = normalizeNumber(ownNumber);
  const normalizedTo = normalizeNumber(number);

  if (!normalizedOwn) {
    console.log('‚ùå N√∫mero pr√≥prio indispon√≠vel');
    return { success: false, reason: 'own_number_unavailable' };
  }

  // GARANTIR: Somente enviar mensagens usando o n√∫mero conectado no bot
  // O bot s√≥ pode enviar mensagens atrav√©s do n√∫mero que est√° conectado
  // N√£o h√° restri√ß√£o de destinat√°rio, mas o remetente SEMPRE ser√° o n√∫mero conectado

  // Valida√ß√£o adicional: garantir que o bot est√° conectado com um n√∫mero v√°lido
  if (!connectedNumber || !isFullyValidated) {
    console.log('‚ùå Bot n√£o est√° conectado ou validado completamente');
    return { success: false, reason: 'bot_not_connected' };
  }

  // GARANTIA FINAL: Verificar se o n√∫mero conectado √© consistente
  if (normalizedOwn !== normalizeNumber(connectedNumber)) {
    console.log('‚ùå Inconsist√™ncia detectada entre n√∫mero conectado e n√∫mero do cliente');
    console.log(`üìû N√∫mero conectado: ${connectedNumber}`);
    console.log(`üÜî N√∫mero do cliente: ${ownNumber}`);
    return { success: false, reason: 'number_inconsistency' };
  }

  // GARANTIA DE SEGURAN√áA: Verificar se o n√∫mero conectado √© v√°lido
  if (!normalizedOwn || normalizedOwn.length < 10) {
    console.log('‚ùå N√∫mero conectado inv√°lido ou muito curto');
    return { success: false, reason: 'invalid_connected_number' };
  }
  if (!normalizedOwn || normalizedOwn.length < 10) {
    console.log('‚ùå N√∫mero conectado inv√°lido ou muito curto');
    return { success: false, reason: 'invalid_connected_number' };
  }

  // Valida√ß√£o do n√∫mero
  const cleanNumber = normalizedTo;
  if (cleanNumber.length < 10) {
    console.log(`‚ùå N√∫mero inv√°lido: ${number}`);
    return { success: false, reason: 'invalid_number' };
  }

  try {
    console.log(`üì§ Enviando mensagem para ${number}...`);
    console.log(`üìû Remetente (n√∫mero conectado): ${connectedNumber}`);
    console.log(`üÜî N√∫mero pr√≥prio (client.info): ${ownNumber}`);
    console.log(`‚úÖ Garantia: Mensagem ser√° enviada APENAS atrav√©s do n√∫mero conectado`);
    console.log(`üî¢ N√∫mero original: ${number}`);
    console.log(`üî¢ N√∫mero normalizado: ${cleanNumber}`);
    
    // Garantir que o n√∫mero est√° no formato correto para WhatsApp
    const chatId = `${cleanNumber}@c.us`;
    console.log(`üí¨ Chat ID: ${chatId}`);
    
    // Verifica se o chat existe
    let chat;
    try {
      chat = await client.getChatById(chatId);
      if (!chat) {
        console.log(`‚ùå Chat n√£o encontrado para ${number}`);
        return { success: false, reason: 'chat_not_found' };
      }
    } catch (chatError) {
      console.log(`‚ö†Ô∏è Erro ao verificar chat para ${number}: ${chatError.message}`);
      // Tentar enviar mesmo assim
    }

    // Processar template de mensagem
    let finalMessage;
    
    if (typeof messageData === 'string') {
      // Mensagem simples
      finalMessage = messageData;
    } else if (messageData.template) {
      // Template com dados
      finalMessage = processMessageTemplate(messageData.template, messageData.data);
    } else if (messageData.message) {
      // Mensagem com dados adicionais
      finalMessage = processMessageTemplate(messageData.message, messageData);
    } else {
      console.log(`‚ùå Formato de mensagem inv√°lido para ${number}`);
      return { success: false, reason: 'invalid_message_format' };
    }

    // Validar se a mensagem n√£o est√° vazia
    if (!finalMessage || finalMessage.trim() === '') {
      console.log(`‚ùå Mensagem vazia para ${number}`);
      return { success: false, reason: 'empty_message' };
    }

    // Tentar enviar a mensagem com retry
    let retryCount = 0;
    const maxRetries = 3;
    
    while (retryCount < maxRetries) {
      try {
        // Usar m√©todo mais seguro para envio
        const message = await client.sendMessage(chatId, finalMessage);
        
        if (message && message.id) {
          console.log(`‚úÖ Mensagem enviada para ${number}`);
          console.log(`üìû Remetente confirmado: ${connectedNumber}`);
          console.log(`üÜî ID da mensagem: ${message.id._serialized}`);
          console.log(`üìù Conte√∫do: ${finalMessage.substring(0, 100)}${finalMessage.length > 100 ? '...' : ''}`);
          console.log(`üîí GARANTIA: Mensagem enviada APENAS atrav√©s do n√∫mero conectado ${connectedNumber}`);
          
          // Log de auditoria para rastreamento
          console.log(`üìä AUDITORIA: ${new Date().toISOString()} - Enviado de ${connectedNumber} para ${number}`);
          
          // Enviar confirma√ß√£o de envio para a API
          await sendMessageConfirmationToAPI(number, message.id._serialized, 'sent');
          
          return { success: true, messageId: message.id };
        } else {
          throw new Error('Mensagem n√£o foi enviada corretamente');
        }
      } catch (sendError) {
        retryCount++;
        console.log(`‚ö†Ô∏è Tentativa ${retryCount} falhou para ${number}: ${sendError.message}`);
        
        if (retryCount >= maxRetries) {
          console.error(`‚ùå Todas as tentativas falharam para ${number}`);
          return { success: false, reason: sendError.message };
        }
        
        // Aguardar antes da pr√≥xima tentativa
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
    
  } catch (err) {
    console.error(`‚ùå Erro ao enviar para ${number}:`, err.message);
    return { success: false, reason: err.message };
  }
}

// Fun√ß√£o melhorada para consumidor da fila
async function startQueueConsumer(client) {
  // Evitar m√∫ltiplas conex√µes simult√¢neas
  if (rabbitConnection && !rabbitConnection.closed) {
    console.log('üîå Conex√£o RabbitMQ j√° existe, reutilizando...');
    return;
  }
  
  let connection, channel;
  
  try {
    console.log('üîå Conectando ao RabbitMQ...');
    console.log(`üìç Host: ${rabbitConfig.hostname}:${rabbitConfig.port}`);

    const url = RABBITMQ_URL + '?heartbeat=30';
    connection = await amqp.connect(url);
    channel = await connection.createChannel();

    // Atribuir √†s vari√°veis globais
    rabbitConnection = connection;
    rabbitChannel = channel;

    const queue = process.env.RABBITMQ_QUEUE || 'whatsapp.outgoing';
    await channel.assertQueue(queue, { durable: true });

    console.log(`üéß Aguardando mensagens na fila: ${queue}...`);

    channel.consume(queue, async (msg) => {
      if (msg !== null) {
        try {
          const payload = JSON.parse(msg.content.toString());
          console.log('üì¶ Mensagem recebida da fila:', payload);

          // Tratar comandos especiais
          if (payload.command === 'disconnect') {
            console.log('üõ†Ô∏è Comando disconnect recebido. Limpando sess√£o e encerrando...');
            try {
              clearQRCodeTimer();
              clearValidationTimer();
              try { await client.logout(); } catch (_) {}
              clearAllSessions();
            } finally {
              channel.ack(msg);
              process.exit(0);
            }
            return;
          }

          if (payload.command === 'generate_qr') {
            console.log('üõ†Ô∏è Comando generate_qr recebido. Reinicializando cliente para emitir novo QR...');
            try {
              clearQRCodeTimer();
              clearValidationTimer();
              try { await client.logout(); } catch (_) {}
              isConnected = false;
              isFullyValidated = false;
              connectedNumber = null;
              client.initialize();
            } catch (cmdErr) {
              console.error('‚ùå Erro ao processar comando generate_qr:', cmdErr.message);
            }
            channel.ack(msg);
            return;
          }

          // Valida√ß√£o do payload
          if (!payload.phone && !payload.Phone) {
            console.error('‚ùå Payload inv√°lido: n√∫mero n√£o encontrado', payload);
            channel.nack(msg, false, false);
            return;
          }

          // Suportar diferentes formatos de payload
          const phone = payload.phone || payload.Phone;
          const messageData = {
            message: payload.message || payload.Message,
            template: payload.template || payload.Template,
            data: payload.data || payload.Data || payload
          };

          const result = await sendOne(client, phone, messageData);
          
          if (result.success) {
          channel.ack(msg);
            console.log(`‚úÖ Mensagem processada com sucesso para ${phone}`);
          } else if (result.reason === 'waiting_validation') {
            // N√£o fazer ack nem nack - aguardar valida√ß√£o
            console.log(`‚è≥ Mensagem para ${phone} aguardando valida√ß√£o`);
          } else {
            console.log(`‚ö†Ô∏è Falha no envio para ${phone}: ${result.reason}`);
            channel.nack(msg, false, false);
          }
        } catch (error) {
          console.error('‚ùå Erro ao processar mensagem:', error.message);
          channel.nack(msg, false, false);
        }
      }
    });

    // Tratamento de desconex√£o
    connection.on('close', () => {
      console.log('üîå Conex√£o RabbitMQ fechada');
      setTimeout(() => startQueueConsumer(client), 5000);
    });

    connection.on('error', (err) => {
      console.error('‚ùå Erro na conex√£o RabbitMQ:', err.message);
    });

  } catch (err) {
    console.error('‚ùå Erro ao conectar ao RabbitMQ:', err.message);
    console.log('üîÑ Tentando reconectar em 10 segundos...');
    setTimeout(() => startQueueConsumer(client), 10000);
  }
}

// -----------------------------------------------------------------------------
//                                  L√ìGICA DE FILAS
// -----------------------------------------------------------------------------

async function initializeRabbitMQ() {
  try {
    const url = RABBITMQ_URL + '?heartbeat=30';
    rabbitConnection = await amqp.connect(url);
    rabbitChannel = await rabbitConnection.createChannel();
    console.log('‚úÖ Conex√£o RabbitMQ estabelecida.');
    await rabbitChannel.assertQueue('out.qrcode', { durable: true });
    await rabbitChannel.assertQueue('whatsapp.incoming', { durable: true });
    await rabbitChannel.assertQueue('whatsapp.outgoing', { durable: true });
    await rabbitChannel.assertQueue('whatsapp.message-status', { durable: true });
    await rabbitChannel.assertQueue('session.status', { durable: true });
  } catch (error) {
    console.error('‚ùå Falha ao conectar ao RabbitMQ:', error.message);
  }
}

// Tratamento de sinais para graceful shutdown
process.on('SIGINT', async () => {
  clearQRCodeTimer();
  clearValidationTimer();
  console.log('\nüõë Recebido SIGINT, encerrando...');
  try {
    await client.destroy();
    console.log('‚úÖ Cliente WhatsApp encerrado');
  } catch (error) {
    console.error('‚ùå Erro ao encerrar cliente:', error.message);
  }
  clearAllSessions();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  clearQRCodeTimer();
  clearValidationTimer();
  console.log('\nüõë Recebido SIGTERM, encerrando...');
  try {
    await client.destroy();
    console.log('‚úÖ Cliente WhatsApp encerrado');
  } catch (error) {
    console.error('‚ùå Erro ao encerrar cliente:', error.message);
  }
  clearAllSessions();
  process.exit(0);
});

// Inicializa√ß√£o do cliente
console.log('üöÄ Iniciando Zap Blaster...');
console.log(`üìÅ Sess√£o: ${sessionPath}`);

// Pol√≠tica: sempre iniciar sem sess√£o
clearAllSessions();
console.log('üì± Ser√° necess√°rio escanear QR Code');

showConnectionStatus();

// Inicializar RabbitMQ primeiro
initializeRabbitMQ().then(() => {
  console.log('‚úÖ RabbitMQ inicializado');
}).catch((error) => {
  console.error('‚ùå Erro ao inicializar RabbitMQ:', error.message);
});

// Inicializar cliente apenas uma vez
client.initialize().then(() => {
  console.log('‚úÖ Cliente WhatsApp inicializado com sucesso!');
}).catch((error) => {
  console.error('‚ùå Erro ao inicializar cliente:', error.message);
  console.log('üîÑ Tentando reinicializar em 10 segundos...');
  
  // Tentar reinicializar ap√≥s 10 segundos
  setTimeout(() => {
    console.log('üîÑ Reinicializando cliente WhatsApp...');
    client.initialize().then(() => {
      console.log('‚úÖ Cliente WhatsApp reinicializado com sucesso!');
    }).catch((retryError) => {
      console.error('‚ùå Erro na reinicializa√ß√£o:', retryError.message);
      console.log('üì± O bot est√° pronto para receber comandos de gera√ß√£o de QR');
    });
  }, 10000);
});

// Servidor HTTP + Socket.IO para status em tempo real (porta 3000)
const app = express();
app.use(cors());
app.use(express.json());
const server = http.createServer(app);
const io = new Server(server, {
  cors: { origin: '*', methods: ['GET', 'POST'] }
});

function emitStatus() {
  const payload = {
    isConnected,
    isFullyValidated,
    connectedNumber,
    timestamp: new Date().toISOString()
  };
  io.sockets.emit('status', payload);
}

app.get('/status', (req, res) => {
  res.json({
    isConnected,
    isFullyValidated,
    connectedNumber,
    timestamp: new Date().toISOString()
  });
});

app.get('/health', (req, res) => res.json({ status: 'OK' }));

io.on('connection', socket => {
  console.log('üîå Cliente socket conectado');
  // Enviar status atual imediatamente
  emitStatus();
  socket.on('disconnect', () => console.log('üîå Cliente socket desconectado'));
});

// Heartbeat de status
setInterval(() => {
  emitStatus();
  sendSessionStatusToAPI();
}, 15000);

const PORT = parseInt(process.env.BOT_STATUS_PORT || '3000', 10);
server.listen(PORT, () => {
  console.log(`üåê Status server ouvindo em http://localhost:${PORT}`);
});

// Fun√ß√£o para enviar status de sess√£o para a API
async function sendSessionStatusToAPI() {
  try {
    // Verificar se h√° conex√£o RabbitMQ
    if (!rabbitConnection || !rabbitChannel) {
      return;
    }

    // Preparar dados do status da sess√£o
    const sessionStatus = {
      sessionConnected: isConnected,
      connectedNumber: connectedNumber,
      isFullyValidated: isFullyValidated,
      lastActivity: new Date().toISOString(),
      instanceId: instanceId,
      timestamp: Date.now()
    };

    // Enviar para fila RabbitMQ
    const queueName = 'session.status';
    const messageBuffer = Buffer.from(JSON.stringify(sessionStatus));
    
    await rabbitChannel.assertQueue(queueName, { durable: true });
    await rabbitChannel.sendToQueue(queueName, messageBuffer, {
      persistent: true,
      headers: {
        'content-type': 'application/json',
        'timestamp': new Date().toISOString()
      }
    });

    console.log(`üì§ Status de sess√£o enviado para RabbitMQ: ${isConnected ? 'CONECTADO' : 'DESCONECTADO'}`);
  } catch (error) {
    console.error('‚ùå Erro ao enviar status de sess√£o:', error.message);
  }
}
